


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > WeeklyOnsiteSearchStrategy</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">is.murmur.Model.Services.SearchStrategy</a>
</div>

<h1>Coverage Summary for Class: WeeklyOnsiteSearchStrategy (is.murmur.Model.Services.SearchStrategy)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">WeeklyOnsiteSearchStrategy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.9%
  </span>
  <span class="absValue">
    (7/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74.2%
  </span>
  <span class="absValue">
    (66/89)
  </span>
</td>
</tr>
  <tr>
    <td class="name">WeeklyOnsiteSearchStrategy$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.9%
  </span>
  <span class="absValue">
    (7/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.6%
  </span>
  <span class="absValue">
    (67/91)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package is.murmur.Model.Services.SearchStrategy;
&nbsp;
&nbsp;import is.murmur.Model.Beans.*;
&nbsp;import is.murmur.Model.Helpers.*;
&nbsp;import jakarta.persistence.EntityManager;
&nbsp;import jakarta.persistence.Query;
&nbsp;import org.json.JSONArray;
&nbsp;import org.json.JSONObject;
&nbsp;
&nbsp;import java.time.LocalDate;
&nbsp;import java.time.LocalTime;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;
&nbsp;/**
&nbsp; * Implementazione della strategia di ricerca onsite settimanale.
&nbsp; * &lt;p&gt;
&nbsp; * Questa classe implementa l&#39;interfaccia {@link SearchStrategy} e definisce la logica
&nbsp; * per eseguire una ricerca di lavoratori (worker) che offrono servizi onsite su base settimanale.
&nbsp; * I criteri di ricerca includono la professione, il range di tariffa oraria, le date di inizio e fine,
&nbsp; * gli intervalli orari per ciascun giorno della settimana, e i dettagli di localizzazione.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; 
&nbsp; */
<b class="fc">&nbsp;public class WeeklyOnsiteSearchStrategy implements SearchStrategy {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Esegue la ricerca dei lavoratori in base ai criteri settimanali specificati per il servizio onsite.
&nbsp;     * &lt;p&gt;
&nbsp;     * Il metodo estrae i parametri di ricerca dai criteri forniti, compresi gli intervalli settimanali
&nbsp;     * e i dettagli di localizzazione. Esegue una query sul database per recuperare gli utenti di tipo &quot;WORKER&quot;,
&nbsp;     * le loro carriere e il numero civico associato alla localizzazione, filtrando in base a professione,
&nbsp;     * tariffa oraria e localizzazione. Per ogni lavoratore, viene controllata la presenza di collisioni
&nbsp;     * con gli intervalli orari specificati per ogni giorno compreso tra la data di inizio e quella di fine.
&nbsp;     * I lavoratori senza collisioni vengono aggiunti ai risultati, che vengono infine ordinati per priorità
&nbsp;     * e formattati in un oggetto JSON.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param criteria I criteri di ricerca che includono professione, tariffa oraria, date, intervalli settimanali e localizzazione.
&nbsp;     * @return Una stringa in formato JSON contenente i criteri di ricerca e i risultati, oppure un messaggio di errore.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String search(Criteria criteria) {
&nbsp;        // Ottiene l&#39;EntityManager per interagire con il database
<b class="fc">&nbsp;        EntityManager em = JPAUtil.getEntityManagerFactory().createEntityManager();</b>
<b class="fc">&nbsp;        String json = &quot;&quot;;</b>
&nbsp;        try {
&nbsp;            // Estrae i parametri di ricerca dai criteri
<b class="fc">&nbsp;            String profession = criteria.getProfession();</b>
<b class="fc">&nbsp;            double hourlyRateMin = criteria.getHourlyRateMin();</b>
<b class="fc">&nbsp;            double hourlyRateMax = criteria.getHourlyRateMax();</b>
<b class="fc">&nbsp;            LocalDate startDate = criteria.getStartDate();</b>
<b class="fc">&nbsp;            LocalDate endDate = criteria.getEndDate();</b>
<b class="fc">&nbsp;            Map&lt;String, TimeInterval&gt; weeklyIntervals = criteria.getWeeklyIntervals();</b>
&nbsp;
&nbsp;            // Prepara liste per i giorni della settimana e relativi intervalli (opzionale)
<b class="fc">&nbsp;            List&lt;String&gt; dayOfWeekList = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            List&lt;LocalTime&gt; dayOfWeekStartTimes = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            List&lt;LocalTime&gt; dayOfWeekEndTimes = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;String, TimeInterval&gt; entry : weeklyIntervals.entrySet()) {</b>
<b class="fc">&nbsp;                String dayOfWeek = entry.getKey().toUpperCase();</b>
<b class="fc">&nbsp;                TimeInterval interval = entry.getValue();</b>
<b class="fc">&nbsp;                dayOfWeekList.add(dayOfWeek);</b>
<b class="fc">&nbsp;                dayOfWeekStartTimes.add(interval.getStart());</b>
<b class="fc">&nbsp;                dayOfWeekEndTimes.add(interval.getEnd());</b>
&nbsp;            }
&nbsp;            // Verifica che gli intervalli settimanali non siano vuoti
<b class="pc">&nbsp;            if (dayOfWeekList.isEmpty()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Weekly intervals cannot be empty for a weekly search.&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Estrae i dettagli di localizzazione dai criteri
<b class="fc">&nbsp;            String city = criteria.getCity();</b>
<b class="fc">&nbsp;            String street = criteria.getStreet();</b>
<b class="fc">&nbsp;            String district = criteria.getDistrict();</b>
<b class="fc">&nbsp;            String region = criteria.getRegion();</b>
<b class="fc">&nbsp;            String country = criteria.getCountry();</b>
&nbsp;
&nbsp;            // Crea la query per selezionare gli utenti, le loro carriere e il numero civico
<b class="fc">&nbsp;            Query query = em.createQuery(</b>
&nbsp;                            &quot;select u, c, aa.location.streetNumber from User u &quot; +
&nbsp;                                    &quot;join Planner p on p.user.id = u.id &quot; +
&nbsp;                                    &quot;join Career c on c.worker.id = u.id &quot; +
&nbsp;                                    &quot;join Daily d on d.schedule.id = p.schedule.id &quot; +
&nbsp;                                    &quot;join Activityarea aa on aa.worker.id = u.id &quot; +
&nbsp;                                    &quot;where u.type = &#39;WORKER&#39; &quot; +
&nbsp;                                    &quot;and c.profession.name = :profession &quot; +
&nbsp;                                    &quot;and c.hourlyRate &gt; :hourlyRateMin &quot; +
&nbsp;                                    &quot;and c.hourlyRate &lt; :hourlyRateMax &quot; +
&nbsp;                                    &quot;and aa.location.city = :city &quot; +
&nbsp;                                    &quot;and aa.location.street = :street &quot; +
&nbsp;                                    &quot;and aa.location.district = :district &quot; +
&nbsp;                                    &quot;and aa.location.region = :region &quot; +
&nbsp;                                    &quot;and aa.location.country = :country&quot;)
<b class="fc">&nbsp;                    .setParameter(&quot;profession&quot;, profession)</b>
<b class="fc">&nbsp;                    .setParameter(&quot;hourlyRateMin&quot;, hourlyRateMin)</b>
<b class="fc">&nbsp;                    .setParameter(&quot;hourlyRateMax&quot;, hourlyRateMax)</b>
<b class="fc">&nbsp;                    .setParameter(&quot;city&quot;, city)</b>
<b class="fc">&nbsp;                    .setParameter(&quot;street&quot;, street)</b>
<b class="fc">&nbsp;                    .setParameter(&quot;district&quot;, district)</b>
<b class="fc">&nbsp;                    .setParameter(&quot;region&quot;, region)</b>
<b class="fc">&nbsp;                    .setParameter(&quot;country&quot;, country);</b>
&nbsp;
&nbsp;            // Esegue la query e ottiene i risultati
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc">&nbsp;            List&lt;Object[]&gt; queryResults = query.getResultList();</b>
<b class="fc">&nbsp;            List&lt;Result&gt; results = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;            // Itera sui risultati della query e controlla le collisioni per ogni lavoratore
<b class="pc">&nbsp;            for (Object[] row : queryResults) {</b>
<b class="nc">&nbsp;                User worker = (User) row[0];</b>
<b class="nc">&nbsp;                Career career = (Career) row[1];</b>
<b class="nc">&nbsp;                Short streetNumber = (Short) row[2];</b>
&nbsp;
<b class="nc">&nbsp;                boolean hasCollision = false;</b>
&nbsp;
&nbsp;                // Controlla ogni giorno compreso tra startDate ed endDate
<b class="nc">&nbsp;                for (LocalDate date = startDate; !date.isAfter(endDate); date = date.plusDays(1)) {</b>
<b class="nc">&nbsp;                    String dayOfWeek = date.getDayOfWeek().name();</b>
&nbsp;
&nbsp;                    // Se esiste un intervallo per il giorno corrente, verifica la collisione
<b class="nc">&nbsp;                    if (weeklyIntervals.containsKey(dayOfWeek)) {</b>
<b class="nc">&nbsp;                        TimeInterval interval = weeklyIntervals.get(dayOfWeek);</b>
<b class="nc">&nbsp;                        if (Collision.detect(worker, date, interval)) {</b>
<b class="nc">&nbsp;                            hasCollision = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Aggiunge il lavoratore ai risultati se non sono state rilevate collisioni
<b class="nc">&nbsp;                if (!hasCollision) {</b>
<b class="nc">&nbsp;                    results.add(new Result(worker, career, streetNumber));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Ordina i risultati in base alla priorità del lavoratore (in ordine decrescente)
<b class="fc">&nbsp;            results.sort(new Comparator&lt;Result&gt;() {</b>
&nbsp;                @Override
&nbsp;                public int compare(Result o1, Result o2) {
<b class="nc">&nbsp;                    return (int) (o2.getWorker().getWorker().getPriority() - o1.getWorker().getWorker().getPriority());</b>
&nbsp;                }
&nbsp;            });
&nbsp;
&nbsp;            // Crea l&#39;oggetto JSON per l&#39;output finale
<b class="fc">&nbsp;            JSONObject output = new JSONObject();</b>
&nbsp;
&nbsp;            // Crea e popola l&#39;oggetto JSON con i criteri di ricerca
<b class="fc">&nbsp;            JSONObject criteriaJson = new JSONObject();</b>
<b class="fc">&nbsp;            criteriaJson.put(&quot;scheduleType&quot;, criteria.getScheduleType());</b>
<b class="fc">&nbsp;            criteriaJson.put(&quot;serviceMode&quot;, criteria.getServiceMode());</b>
<b class="fc">&nbsp;            criteriaJson.put(&quot;profession&quot;, profession);</b>
<b class="fc">&nbsp;            criteriaJson.put(&quot;hourlyRateMin&quot;, hourlyRateMin);</b>
<b class="fc">&nbsp;            criteriaJson.put(&quot;hourlyRateMax&quot;, hourlyRateMax);</b>
<b class="fc">&nbsp;            criteriaJson.put(&quot;startDate&quot;, startDate.toString());</b>
<b class="fc">&nbsp;            criteriaJson.put(&quot;endDate&quot;, endDate.toString());</b>
&nbsp;
&nbsp;            // Aggiunge gli intervalli settimanali in formato JSON
<b class="fc">&nbsp;            JSONObject weeklyIntervalsJson = new JSONObject();</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;String, TimeInterval&gt; entry : weeklyIntervals.entrySet()) {</b>
<b class="fc">&nbsp;                JSONObject intervalJson = new JSONObject();</b>
<b class="fc">&nbsp;                intervalJson.put(&quot;start&quot;, entry.getValue().getStart().toString());</b>
<b class="fc">&nbsp;                intervalJson.put(&quot;end&quot;, entry.getValue().getEnd().toString());</b>
<b class="fc">&nbsp;                weeklyIntervalsJson.put(entry.getKey(), intervalJson);</b>
&nbsp;            }
<b class="fc">&nbsp;            criteriaJson.put(&quot;weeklyIntervals&quot;, weeklyIntervalsJson);</b>
&nbsp;
&nbsp;            // Aggiunge i dettagli di localizzazione
<b class="fc">&nbsp;            criteriaJson.put(&quot;city&quot;, city);</b>
<b class="fc">&nbsp;            criteriaJson.put(&quot;street&quot;, street);</b>
<b class="fc">&nbsp;            criteriaJson.put(&quot;district&quot;, district);</b>
<b class="fc">&nbsp;            criteriaJson.put(&quot;region&quot;, region);</b>
<b class="fc">&nbsp;            criteriaJson.put(&quot;country&quot;, country);</b>
<b class="fc">&nbsp;            output.put(&quot;searchCriteria&quot;, criteriaJson);</b>
&nbsp;
&nbsp;            // Crea un array JSON per contenere i risultati della ricerca
<b class="fc">&nbsp;            JSONArray resultsArray = new JSONArray();</b>
<b class="pc">&nbsp;            for (Result result : results) {</b>
<b class="nc">&nbsp;                JSONObject resultJson = new JSONObject();</b>
<b class="nc">&nbsp;                resultJson.put(&quot;user&quot;, result.getWorker());</b>
<b class="nc">&nbsp;                resultJson.put(&quot;career&quot;, result.getCareer());</b>
<b class="nc">&nbsp;                resultJson.put(&quot;streetNumber&quot;, result.getStreetNumber());</b>
<b class="nc">&nbsp;                resultsArray.put(resultJson);</b>
&nbsp;            }
<b class="fc">&nbsp;            output.put(&quot;results&quot;, resultsArray);</b>
&nbsp;
&nbsp;            // Converte l&#39;oggetto JSON in una stringa formattata con indentazione (2 spazi)
<b class="fc">&nbsp;            json = output.toString(2);</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
&nbsp;            // Stampa lo stack trace in caso di errore
<b class="nc">&nbsp;            e.printStackTrace();</b>
&nbsp;            // Crea un oggetto JSON per rappresentare l&#39;errore
<b class="nc">&nbsp;            JSONObject errorJson = new JSONObject();</b>
<b class="nc">&nbsp;            errorJson.put(&quot;error&quot;, &quot;Server error occurred: &quot; + e.getMessage());</b>
<b class="nc">&nbsp;            json = errorJson.toString();</b>
&nbsp;        } finally {
&nbsp;            // Chiude l&#39;EntityManager per liberare le risorse
<b class="fc">&nbsp;            em.close();</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return json;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-02-17 14:06</div>
</div>
</body>
</html>
